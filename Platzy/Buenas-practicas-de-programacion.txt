
    Principios SOLID
    ----------------
    
    SOLID son cinco principios básicos de la programación orientada a objetos que ayudan a crear software mantenible en el tiempo
    
    S: Single Responsibility Principle (SRP)

    O: Open/Closed Principle (OCP)

    L: Liskov Substitution Principle (LSP)

    I: Interface Segregation Principle (ISP)

    D: Dependency Inversion Principle (DIP)
    
    
    
     S: Single Responsibility Principle (SRP): 
     
            Indica que cada clase tiene que tener un unico objetivo muy puntual.
            
                Las ventajas que estro trae es que es muy facil detectar errores y la reutilizacion de codigo
                
                
                
     O: Open/Closed Principle (OCP):
     
            Open/Closed Principle establece que una entidad de software debe quedarse abierta para su extensión, pero cerrada para su modificación.
            
            Eso significa que si quiero agregar algo nuevo al codigo lo puedo hacer facilmente sin modificar nada (por eso cerrado a la modificacion)
            
            
            
    L: Liskov Substitution Principle (LSP):
    
            El Liskov Substitution Principle establece que cada clase que hereda de otra puede usarse como su padre sin necesidad de conocer las diferencias entre ellas. Para que pueda darse este principio debe cumplir con dos puntos:

                *El cliente debe usar métodos de la clase padre únicamente.
                *La clase hija no debe alterar el comportamiento de los métodos de la clase padre.
                
            Osea que una clase hija tiene que agregar compartamietos con respecto a su padre, pero no modificar los ya existentes
            
            
            
     I: Interface Segregation Principle (ISP):
      
           El principio de segregación de interfaces nos dice un poco como estructurar nuestras interfaces de modo que cuando una clase implementa una interface, no se le exija implementar métodos que no necesita.
           
           
           
     D: Dependency Inversion Principle (DIP):
     
     
            Dependency Inversion Principle detalla que los módulos de alto nivel no deben depender de los de bajo nivel, ambos deben depender de abstracciones.
             Las abstracciones no deben depender de los detalles, los detalles deben depender de las abstracciones.
            
            (No me quedo muy claro)
            
            
            
    
    Patrones de diseño
    ------------------           
           
   Un patron de diceño es una solucion estandarizada ante ciertas situaciones
   
   Los patrones de diceño de dividen en tres grupos:
   
        Creacionales: Creacion y configuracion de objetos
        
        Estructurales: Separan la interfaz de la implementacion
        
        Compartamietos: Describe como se comunican los distintos objetos
        
        
        
        
 Patron Singleton:
 -----------------
 
    La idea de este patron es tener una uncia INSTANCIA de una clase determinada a lo largo de toda la aplicacion.
    
       
    Estructura general: (con la sintaxis de PHP)
    
            classSingleton{
        
                private static $theInstance = null;  <-- privado y estatico, nadie fuera de la clase podra ver o modificar esto
                
                public static function getInstance(){  <-- una funcion especial que crea la instancia
                
                    if ( self::$theInstance === null ) {   <-- este if crea la instancia solo si no existe previamente, 
                        self::$theInstance = new sefl();
                    }
                    returnself::$theInstance    <-- si la instanca no existia, la crea y la retorna, pero si ya existia de antes, retorna la creada previamente, asi nos aseguramos que no existan 2 instancias de la misma clase
                }
            }
           
           
 Patron Factory:
 ---------------
 
    Este patron se utiliza cuando la cracion de un objeto es compleja y requiere varios parametros
    
    
    Estructura general: (con la sintaxis de PHP)
    
    class AutomobileFactory{
    
        private static $modelo = 2019;   <--- un valor que se repite en todas las instancia

        public static function create($marca){  <--- una funcion que se encarga de crear la instancia, pasando por parametro los valores minimos 
        
            return new Automobile($marca, self::$modelo);  <--- retorna la instancia ya lista con "Sus partes ensambladas"
        }
    }
          
          

 Patron Command:
 ---------------
           
     Este patron se utiliza cuando se tiene que realizar una operacion compleja desde varios puntos de entrada
     
     (a completar)
           
           
           
           
           
Tipo de Tests:
--------------

    Unit Testing: Evaluamos el funcionamiento de los componentes individualmente.
    
    Integration Testing: Validar la interacción entre los componentes y el sistema completo.
    
    
    
Documentación:
---------------
    ¿Qué documentar?

        Como implementar nueva funcionalidad.   
        Como se realizan las pruebas.
        Lo mínimo que necesita las personas que quieren colaborar o heredar tu proyecto.
    
    ¿Como documentar?
    
        UML como documentación.
        Comentarios
        
    ¿Dónde documentar?
    
        Propio código.
        Sistema de documentación.
        Wiki
        Ficheros externos.
        README
        
    ¿Cuándo documentar?

        Documentar inmediatamente después de codear.
        Cuando se resuelve un problema, documentar la solución.
        
        
        
        
 ¿Como determinar si un codigo es o no de buena calidad?
 
    para que sea de buan calidad tiene que cumplir:
        
            Legibilidad <---- Que sea facil de leer, que de un viscazo sse pueda desucir que hacer
            
            Mantenibilidad <---- Que el codigo preaparado para midificaciones a lo largo del tiempo sin complicaciones
            
            Testeabilidad  <---- Que este preparado para ser testeado de forma automatizada
    
    
           
           
           
           
           
           
           
           
           
           
           
           
           
           
           
            
            
 
 
